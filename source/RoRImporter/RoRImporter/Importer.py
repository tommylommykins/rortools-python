#TODO: Remove comments from list of beams. Should instead be done by inspection of comment line numbers.
#TODO: set_beam_defaults

from Py3dsMax import mxs

import re

import TruckParser; reload(TruckParser)
import Names; reload(Names)

class Importer:
    def __init__(self):
        #Load global RoR data definitions
        mxs.fileIn("../global/definitions.ms")
        self.parser = TruckParser.TruckParser()
        self.parser.load_truck(mxs.getopenfilename())
        self._load_node_positions()
        self._import_global_data()
        self.make_node_beam()
        
    def _load_node_positions(self):
        self.node_positions = [mxs.Point3(n['x'], n['y'], n['z']) for n in self.parser.nodes]

    def make_node_beam(self):
        """Generates the 3ds Max representation of the beams of a truck.
        """
        self._make_beam_object_set("beam_1")
        for beam in self.parser.beams:
            if beam.__class__ == str:
                self._make_beam_object_set(beam)
                continue
            
            if self._new_beam_default_in_beam_section(beam):
                self._make_beam_object_set(beam)
            
            beam_object = self._select_beam_object(beam)
            start_point = self.node_positions[beam['node1']]
            end_point = self.node_positions[beam['node2']]
            print beam
            self._draw_line(beam_object, start_point, end_point)
            
    def _draw_line(self, beam_object, pos1, pos2):
        """Draws a line between two points of a line object
        """
        print beam_object
        spline = mxs.AddNewSpline(beam_object)
        mxs.AddKnot(beam_object, spline, Names.CORNER, Names.LINE, pos1)
        mxs.AddKnot(beam_object, spline, Names.CORNER, Names.LINE, pos2)
        mxs.UpdateShape(beam_object)
        
    def _new_beam_default_in_beam_section(self, beam):
        if not hasattr(self, "cached_beam_default", ()):
            
            
    def _make_beam_name(self, parsed_name):
        """beam names generated by the maxscript exporters have their visibility/ropeness/supportness
        tacked onto their names. When reimported with this script, this needs to be removed.
        
        Additionally, sometimes when objects are copied in 3dsmax, a number is appended. This is removed
        from the end of these suffixes too.
        
        Otherwise, these suffixes would build up forever, resulting in names like
        beam_001_invisible_invisible001_invisible.
        """
        parsed_name = parsed_name.strip()
        parsed_name = re.sub(r'^;', "", parsed_name)
        end_of_name_matcher = re.compile(r'_(invisible|rope|support)\d*$', re.I)
        while re.search(end_of_name_matcher, parsed_name):
            parsed_name = re.sub(end_of_name_matcher, "", parsed_name)
            
        return parsed_name
            
    def _select_beam_object(self, beam):
        """Selects a beam object from a set, so that a beam may be placed into the correct one.
        The correct object is chosen by inspection of the arguments on the beam itself. 
        """
        if not 'options' in beam: return self.beam_object_set['normal']
        
        option = beam['options']
        
        if re.search(r'n', option, re.I): return self.beam_object_set['normal']
        
        if re.search(r'i', option, re.I) and \
           re.search(r'r', option, re.I) and \
           re.search(r's', option, re.I): return self.beam_object_set['invisible_rope_support']
        
        if re.search(r'i', option, re.I) and re.search(r'r', option, re.I): return self.beam_object_set['invisible_rope']
        if re.search(r'i', option, re.I) and re.search(r's', option, re.I): return self.beam_object_set['invisible_support']
        if re.search(r'r', option, re.I) and re.search(r's', option, re.I): return self.beam_object_set['rope_support']
        
        if re.search(r'i', option, re.I): return self.beam_object_set['invisible']
        if re.search(r'r', option, re.I): return self.beam_object_set['rope']
        if re.search(r's', option, re.I): return self.beam_object_set['support']
        
        #default, used for invalid arguments 
        return self.beam_object_set['normal']
        
    def _make_beam_object_set(self, name):
        """To help separate beams in the editor, they are grouped according to comments in the truck file:
        Wherever there is a comment in the beams section, a new Max object is created for all subsequent
        beams, whose name is taken from that comment.
        Individual beams can take various arguments in truck files. 3ds max cannot easily support this,
        so instead beams with the same arguments are grouped together.

        This method creates a set of beam objects, one for each possible combination of arguments
        so that individual beams can be placed in the appropriate subgroups. For each beam that 
        is imported, the appropriate subgroup is chosen by _select_beam_object. 
        """
        #the old beam object set becomes unused at this point, so any empty objects should be
        #deleted now.
        self._delete_unused_beam_objects()
        combinations = self._all_combinations(("invisible", "rope", "support"))
        name = "beam_" + self._make_beam_name(name)
        #print "making " + name
        ret = {}
        
        for combination in combinations:
            combination_name = "_".join(combination)
            beam_object_name = name + "_" + combination_name
            beam_object = self._spline_shape(beam_object_name)
            ret[combination_name] = beam_object
            mxs.CustAttributes.add(beam_object, mxs.RoRBeam)
            
            for property_name in combination:
                setattr(beam_object, property_name, True)
                
        #normal (ie. no options) is a special case:
        normal = self._spline_shape(name)
        mxs.CustAttributes.add(normal, mxs.RoRBeam)
        ret['normal'] = normal
        self.beam_object_set = ret
    
    def _delete_unused_beam_objects(self):
        """Deletes all objects in a beam object set if they contain no beams.
        Done because beam objects are pregenerated without first finding out whether
        all combinations are actually are needed or not, so some non-useful ones are
        generated.
        """
        if not hasattr(self, "beam_object_set"): 
            return
        for beam_object in self.beam_object_set.itervalues():
            if mxs.numSplines(beam_object) == 0:
                mxs.delete(beam_object)
                
    def _import_global_data(self):
        """Takes truck data which isn't associated with a specific 3ds max object
        (weight, name, author, etc.) and assigns it to a box located at the origin.
        This allows it to be edited and exported later
        """
        #Make the box
        global_data_box = mxs.box(length=0.08, width=0.08, height=0.08, \
                                  pos=mxs.Point3(0, 0, 0), wirecolor=mxs.red)
        global_data_box.name = "global_data_" + self.parser.truck_name
        mxs.CustAttributes.add(global_data_box, mxs.RoRGlobals)
        global_data_box.global_data = self.parser.global_data

    def _all_combinations(self, lst):
        """Generates the set of all possible combinations of all lengths of items in a list"""
        import itertools
        ret = []
        for i in range(len(lst)):
            length = i + 1
            ret.extend(list(itertools.combinations(lst, length)))
        return ret            
    
    def _spline_shape(self, name):
        """Generates an empty 3ds max splineshape"""
        return mxs.SplineShape(pos=mxs.Point3(0, 0, 0), name=name)

class RoRParseError(Exception):
    def __init__(self, value):
        self.msg = value 
